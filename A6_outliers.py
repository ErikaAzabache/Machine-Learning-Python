# -*- coding: utf-8 -*-
"""Assignment_6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iOGqIuR4rUHfCUfRsDaKTIwwJkonvgZk

### Get digits
"""

from google.colab import drive, auth
auth.authenticate_user()
import requests
gcloud_token = !gcloud auth print-access-token
drive.mount('/content/drive', force_remount=True)

with open('/content/drive/My Drive/Colab Notebooks/Assignment_4_Script.py') as infile:
    exec(infile.read())

import struct
import matplotlib.pyplot as plt
from array import array as pyarray
import numpy as np
from array import array
import pylab as pyl
import numpy.linalg as LA

MNIST_dir = '/content/drive/My Drive/Data/MNIST_dir'

def load_mnist(dataset="training", selecteddigits=range(10), path=MNIST_dir):

    #Check training/testing specification. MUST be "training" (default) or "testing"
    if dataset == "training":
        fname_digits = path + '/' + 'train-images.idx3-ubyte'
        fname_labels = path + '/' + 'train-labels.idx1-ubyte'
    elif dataset == "testing":
        fname_digits = path + '/' + 't10k-images.idx3-ubyte'
        fname_labels = path + '/' + 't10k-labels.idx1-ubyte'
    else:
        raise ValueError("dataset MUST be 'testing' or 'training'")
        
        
    #Import digits data
    digitsfileobject = open(fname_digits, 'rb')
    magic_nr, size, rows, cols = struct.unpack(">IIII", digitsfileobject.read(16))
    digitsdata = array("B", digitsfileobject.read())
    digitsfileobject.close()

    #Import label data
    labelsfileobject = open(fname_labels, 'rb')
    magic_nr, size = struct.unpack(">II", labelsfileobject.read(8))
    labelsdata=array("B",labelsfileobject.read())
    labelsfileobject.close()
    
    #Find indices of selected digits
    indices=[k for k in range(size) if labelsdata[k] in selecteddigits]
    N=len(indices)
    
    #Create empty arrays for X and T
    X = np.zeros((N, rows*cols), dtype=np.uint8)
    T = np.zeros((N), dtype=np.uint8)
    
    #Fill X from digitsdata
    #Fill T from labelsdata
    for i in range(N):
        X[i] = digitsdata[indices[i]*rows*cols:(indices[i]+1)*rows*cols]
        T[i] = labelsdata[indices[i]]
    
    return X,T

def vectortoimg(*args,width=28,size=1):
    """
    Example: vectortoimg(random.random(784)) or vectortoimg(random.random(784),arange(784))
    
    """
    n=len(args)
    fig = plt.figure()
    for i,arg in enumerate(args):
        plt.subplot(1,n,i+1)
        plt.imshow(arg.reshape(width, width),interpolation='None', cmap=pyl.cm.gray)
        plt.axis('off')
    fig.tight_layout(pad=0)
    fig.set_size_inches(w=n*size,h=size)
    plt.show()

label=7
X, T = load_mnist(dataset="training",selecteddigits=[label])
Xtest, Ttest = load_mnist(dataset="testing",selecteddigits=[label])

vectortoimg(X[0],X[1],X[-2],X[-3],size=3)

"""### PCA"""

print(X.shape);
N=np.size(X,0); print(N)
d=np.size(X,1); print(d)

"""As many columns as features are"""

mu=np.mean(X,axis=0);
mu.shape

"""Values should be between 0 and 255"""

print(np.min(mu,axis=0));
print(np.max(mu,axis=0))

Z=X-mu; print(Z.shape)

"""Checking that Z was calculated properly by getting the mean of Z, which should be a vector of zeroes"""

np.allclose(np.mean(Z, axis=0), np.zeros((N,d), dtype=np.uint8))

C=np.cov(Z,rowvar=False);

"""Double checking that C is symetric, which means C and CT should be equal"""

np.allclose(C,C.T)

[lam, V]=LA.eigh(C)

"""Figuring out if the eigenvectors are positioned in the rows or columns:"""

erow=V[-1,:]
np.allclose(np.dot(C,erow),lam[-1]*erow)

ecol=V[:,-1]
np.allclose(np.dot(C,ecol),lam[-1]*ecol)

"""It looks like the eigenvectors are arranged by columns. Now are they arranged in decreasing or increasing order of importance?"""

print(lam[0]);
print(lam[-1]);
lam.shape

"""It looks like it is in increasing order of importance. We would like to make it so it is in decreasing order of importance. To do this, we should reverse (flip) the order of the eigen vectors and values"""

lam=np.flipud(lam);V=np.flipud(V.T);
newrow=V[0,:]; #Check once again
np.allclose(np.dot(C,newrow),lam[0]*newrow)

print(V.shape)

P=np.dot(Z,V.T);print(P.shape)

d_red=50
Vred=V[0:d_red,:]; print(Vred.shape)

Pred=np.dot(Z,Vred.T); print(Pred.shape)

"""### EM on Pred"""

from sklearn.mixture import GaussianMixture
gm = GaussianMixture(n_components=11, covariance_type='full', max_iter=200).fit(Pred)
labels = gm.predict(Pred)
#probs = gm.predict_proba(Pred); print(probs[:15,:])

print(Pred.shape);
print(P.shape)

"""Calculating weights and means of each component (11 "clusters" with their own pdfs)"""

print(gm.converged_);
gm_weights = gm.weights_
gm_means = gm.means_
print(gm_weights.shape);
print(gm_means.shape);

"""### Outliers

Compute the PDF (or its logarithm) at each of the samples in P and use the result to determine the indices of 10 outliers i.e. the 10 least probable samples in P
"""

log_prob=gm.score_samples(Pred);
print(log_prob)

outlierly_ordered=np.argsort(log_prob); # outlierly_ordered.shape: (6265,)
outliers_10_red=Pred[outlierly_ordered[:10]];
outliers_10=X[outlierly_ordered[:10]]
#print(outliers_10);
log_prob_outliers_10=log_prob[outlierly_ordered[:10]];
#print(log_prob_outliers_10);

"""### Writing to template"""

excelfile = '/content/drive/My Drive/Data/Assignment_6_Submission_Template.xlsx'

for i in range(0,11):
  writeExcelData([gm_means[i,:]],excelfile,'Results',i+2,2)
  print('Mean {} has been written!'.format(i))

for i in range(0,11):
  writeExcelData([gm_weights[i]],excelfile,'Results',14+i,2)
  print('Weight {} has been written!'.format(i))

for i in range(0,10):
  writeExcelData([outliers_10[i,:]],excelfile,'Results',26+i,2)
  print('Outlier {} has been written!'.format(i))

vectortoimg(outliers_10[0],outliers_10[1],outliers_10[2],outliers_10[3],outliers_10[4], size=3);
vectortoimg(outliers_10[5],outliers_10[6],outliers_10[7],outliers_10[8],outliers_10[9], size=3)